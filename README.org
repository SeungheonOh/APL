#+TITLE: APL

* Why?
** Python
#+begin_src python
  def __str__(self):
   if type(self.arr[0]) == APArray:
     def rec(arr):
       if len(arr.shape) == 1:
         return chart(fmap(str, arr.arr), arr.shape[0], title=",".join(fmap(str, arr.shape)))
       if len(arr.shape) == 2:
         return chart(fmap(str, arr.arr), arr.shape[1], title=",".join(fmap(str, arr.shape)))
       return chart(["\n".join(fmap(lambda a: rec(arr.at(a)), range(1, arr.shape[0]+1)))], 1, title=",".join(fmap(str, arr.shape)))
     return rec(self)
   else:
     longest = max(fmap(lambda a: numstr(a), self.arr), key=lambda d: len(d))
     fmt = lambda a: '{0: >{width}}'.format(numstr(a), width=len(longest))
     mkStr = lambda arr: " ".join(fmap(fmt, arr.arr)) if len(arr.shape) == 1 else box("\n".join(fmap(lambda a: mkStr(arr.at(a)), range(1, arr.shape[0]+1))), title=",".join(fmap(str, arr.shape)))
     return mkStr(self).rstrip()
#+end_src

** Haskell
#+begin_src haskell
  instance Show a => Show (Array a) where
    show arr
      | length ns == 1 = unwords $ V.toList $ fmap (fmtStr . show) vec
      | otherwise = box title $ intercalate "\n" $ show . at arr . (:[]) <$> [1..head ns]
        where
          ns = shape arr
          vec = value arr
          longest = maximum $ length . show <$> V.toList vec
          fmtStr s = s ++ ([1..longest - length s] >> " ")
          title = intercalate "," $ show <$> ns

  instance Show a => Show (Array (Array a)) where
    show arr
      | length ns <= 2 = chartWithTitle title (head ns) $ show <$> V.toList vec
      | otherwise = box title $ intercalate "\n" $ show . at arr . (:[]) <$> [1..head ns]
      where
          ns = shape arr
          vec = value arr
          title = intercalate "," $ show <$> ns
#+end_src

* Note
** Recursive structures
Simple rose tree structure: 
#+begin_src  haskell
  data Tree a
     = Leaf a
     | Branch [Tree a]
#+end_src

"Fix" can be used to construct a recursive strucure as well.
#+begin_src haskell
  data Fix f = Fix (f (Fix f))
  data TreeF a r = LeafF a | BranchF [r]
  test :: Fix (TreeF Int)
  test = undefined
#+end_src

Because simpling putting its own type hinders one from interfacing with the nested data, it has to be done by recursive strucutres.

For example in non recursive structures,
#+begin_src haskell
  data Array a = Array
    { value :: V.Vector a
    , shape :: [Int]
    } deriving (Eq, Show)

  -- Array (Array (Array (Array ...)))
#+end_src
the nested level can go on and there is no way to handle them all.
#+begin_src haskell
f (Array vec ns) = ... 
#+end_src
Here we have no control of nested levels as we are not able to deconstruct the vector. :(


However in recursive structures, 
#+begin_src haskell
data NestedArray a
  = Node a
  | Nest (Array (NestedArray a))
  deriving (Show)
#+end_src
the structure does the recursion.
#+begin_src haskell
  f (Node a) = ...
  f (Nest a) = ...
#+end_src
Here we have full control of nested levels. :)
